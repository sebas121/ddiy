"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var batchLink_1 = require("../src/batchLink");
var apollo_link_core_1 = require("apollo-link-core");
var batchLink_2 = require("../src/batchLink");
var graphql_tag_1 = require("graphql-tag");
var printer_1 = require("graphql/language/printer");
function requestToKey(request) {
    var queryString = typeof request.query === 'string' ? request.query : printer_1.print(request.query);
    return JSON.stringify({
        variables: request.variables || {},
        query: queryString,
    });
}
function createMockBatchHandler() {
    var mockedResponses = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        mockedResponses[_i] = arguments[_i];
    }
    var mockedResponsesByKey = {};
    var mockBatchHandler = function (operations) {
        return new apollo_link_core_1.Observable(function (observer) {
            var results = operations.map(function (operation) {
                var key = requestToKey(operation);
                var responses = mockedResponsesByKey[key];
                if (!responses || responses.length === 0) {
                    throw new Error("No more mocked responses for the query: " + printer_1.print(operation.query) + ", variables: " + JSON.stringify(operation.variables));
                }
                var _a = responses.shift(), result = _a.result, error = _a.error;
                if (!result && !error) {
                    throw new Error("Mocked response should contain either result or error: " + key);
                }
                if (error) {
                    observer.error(error);
                }
                return result;
            });
            observer.next(results);
        });
    };
    mockBatchHandler.addMockedResponse = function (mockedResponse) {
        var key = requestToKey(mockedResponse.request);
        var _mockedResponses = mockedResponsesByKey[key];
        if (!_mockedResponses) {
            _mockedResponses = [];
            mockedResponsesByKey[key] = _mockedResponses;
        }
        _mockedResponses.push(mockedResponse);
    };
    mockedResponses.map(mockBatchHandler.addMockedResponse);
    return mockBatchHandler;
}
describe('OperationBatcher', function () {
    it('should construct', function () {
        chai_1.assert.doesNotThrow(function () {
            var querySched = new batchLink_2.OperationBatcher({
                batchInterval: 10,
                batchHandler: function () { return null; },
            });
            querySched.consumeQueue();
        });
    });
    it('should not do anything when faced with an empty queue', function () {
        var batcher = new batchLink_2.OperationBatcher({
            batchInterval: 10,
            batchHandler: function () {
                return null;
            },
        });
        chai_1.assert.equal(batcher.queuedRequests.length, 0);
        batcher.consumeQueue();
        chai_1.assert.equal(batcher.queuedRequests.length, 0);
    });
    it('should be able to add to the queue', function () {
        var batcher = new batchLink_2.OperationBatcher({
            batchInterval: 10,
            batchHandler: function () {
                return null;
            },
        });
        var query = (_a = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], _a.raw = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], graphql_tag_1.default(_a));
        var request = {
            operation: { query: query },
        };
        chai_1.assert.equal(batcher.queuedRequests.length, 0);
        batcher.enqueueRequest(request).subscribe({});
        chai_1.assert.equal(batcher.queuedRequests.length, 1);
        batcher.enqueueRequest(request).subscribe({});
        chai_1.assert.equal(batcher.queuedRequests.length, 2);
        var _a;
    });
    describe('request queue', function () {
        var query = (_a = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], _a.raw = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], graphql_tag_1.default(_a));
        var data = {
            author: {
                firstName: 'John',
                lastName: 'Smith',
            },
        };
        var batchHandler = createMockBatchHandler({
            request: { query: query },
            result: { data: data },
        }, {
            request: { query: query },
            result: { data: data },
        });
        var operation = {
            query: query,
        };
        it('should be able to consume from a queue containing a single query', function (done) {
            var myBatcher = new batchLink_2.OperationBatcher({
                batchInterval: 10,
                batchHandler: batchHandler,
            });
            myBatcher.enqueueRequest({ operation: operation }).subscribe(function (resultObj) {
                chai_1.assert.equal(myBatcher.queuedRequests.length, 0);
                chai_1.assert.deepEqual(resultObj, { data: data });
                done();
            });
            var observables = myBatcher.consumeQueue();
            chai_1.assert.equal(observables.length, 1);
        });
        it('should be able to consume from a queue containing multiple queries', function (done) {
            var request2 = {
                query: query,
            };
            var BH = createMockBatchHandler({
                request: { query: query },
                result: { data: data },
            }, {
                request: { query: query },
                result: { data: data },
            });
            var myBatcher = new batchLink_2.OperationBatcher({
                batchInterval: 10,
                batchMax: 10,
                batchHandler: BH,
            });
            var observable1 = myBatcher.enqueueRequest({ operation: operation });
            var observable2 = myBatcher.enqueueRequest({ operation: request2 });
            var notify = false;
            observable1.subscribe(function (resultObj1) {
                chai_1.assert.deepEqual(resultObj1, { data: data });
                if (notify) {
                    done();
                }
                else {
                    notify = true;
                }
            });
            observable2.subscribe(function (resultObj2) {
                chai_1.assert.deepEqual(resultObj2, { data: data });
                if (notify) {
                    done();
                }
                else {
                    notify = true;
                }
            });
            chai_1.assert.equal(myBatcher.queuedRequests.length, 2);
            var observables = myBatcher.consumeQueue();
            chai_1.assert.equal(myBatcher.queuedRequests.length, 0);
            chai_1.assert.equal(observables.length, 2);
        });
        it('should return a promise when we enqueue a request and resolve it with a result', function (done) {
            var BH = createMockBatchHandler({
                request: { query: query },
                result: { data: data },
            });
            var myBatcher = new batchLink_2.OperationBatcher({
                batchInterval: 10,
                batchHandler: BH,
            });
            var observable = myBatcher.enqueueRequest({ operation: operation });
            observable.subscribe(function (result) {
                chai_1.assert.deepEqual(result, { data: data });
                done();
            });
            myBatcher.consumeQueue();
        });
        var _a;
    });
    it('should work when single query', function (done) {
        var batcher = new batchLink_2.OperationBatcher({
            batchInterval: 10,
            batchHandler: function () {
                return new apollo_link_core_1.Observable(function (observer) {
                    setTimeout(observer.complete.bind(observer));
                });
            },
        });
        var query = (_a = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], _a.raw = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], graphql_tag_1.default(_a));
        var operation = { query: query };
        batcher.enqueueRequest({ operation: operation }).subscribe({});
        chai_1.assert.equal(batcher.queuedRequests.length, 1);
        setTimeout(function () {
            chai_1.assert.equal(batcher.queuedRequests.length, 0);
            done();
        }, 20);
        var _a;
    });
    it('should correctly batch multiple queries', function (done) {
        var batcher = new batchLink_2.OperationBatcher({
            batchInterval: 10,
            batchHandler: function () { return null; },
        });
        var query = (_a = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], _a.raw = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], graphql_tag_1.default(_a));
        var operation = { query: query };
        batcher.enqueueRequest({ operation: operation }).subscribe({});
        batcher.enqueueRequest({ operation: operation }).subscribe({});
        chai_1.assert.equal(batcher.queuedRequests.length, 2);
        setTimeout(function () {
            batcher.enqueueRequest({ operation: operation }).subscribe({});
            chai_1.assert.equal(batcher.queuedRequests.length, 3);
        }, 5);
        setTimeout(function () {
            chai_1.assert.equal(batcher.queuedRequests.length, 0);
            done();
        }, 20);
        var _a;
    });
    it('should reject the promise if there is a network error', function (done) {
        var query = (_a = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], _a.raw = ["\n      query {\n        author {\n          firstName\n          lastName\n        }\n      }\n    "], graphql_tag_1.default(_a));
        var operation = {
            query: query,
        };
        var error = new Error('Network error');
        var BH = createMockBatchHandler({
            request: { query: query },
            error: error,
        });
        var batcher = new batchLink_2.OperationBatcher({
            batchInterval: 10,
            batchHandler: BH,
        });
        var observable = batcher.enqueueRequest({ operation: operation });
        observable.subscribe({
            error: function (resError) {
                chai_1.assert.equal(resError.message, 'Network error');
                done();
            },
        });
        batcher.consumeQueue();
        var _a;
    });
});
describe('BatchLink', function () {
    it('does not need any constructor arguments', function () {
        chai_1.assert.doesNotThrow(function () { return new batchLink_1.default({ batchHandler: function () { return apollo_link_core_1.Observable.of(); } }); });
    });
    it('passes forward on', function () {
        var link = apollo_link_core_1.ApolloLink.from([
            new batchLink_1.default({ batchHandler: function () { return apollo_link_core_1.Observable.of(); } }),
        ]);
        apollo_link_core_1.execute(link, {});
    });
});
//# sourceMappingURL=batchLink.js.map