"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var apollo_link_core_1 = require("apollo-link-core");
var OperationBatcher = (function () {
    function OperationBatcher(_a) {
        var batchInterval = _a.batchInterval, _b = _a.batchMax, batchMax = _b === void 0 ? 0 : _b, batchHandler = _a.batchHandler;
        this.queuedRequests = [];
        this.queuedRequests = [];
        this.batchInterval = batchInterval;
        this.batchMax = batchMax;
        this.batchHandler = batchHandler;
    }
    OperationBatcher.prototype.enqueueRequest = function (request) {
        var _this = this;
        var requestCopy = __assign({}, request);
        requestCopy.observable =
            requestCopy.observable ||
                new apollo_link_core_1.Observable(function (observer) {
                    _this.queuedRequests.push(requestCopy);
                    requestCopy.next = requestCopy.next || observer.next.bind(observer);
                    requestCopy.error = requestCopy.error || observer.error.bind(observer);
                    requestCopy.complete =
                        requestCopy.complete || observer.complete.bind(observer);
                    if (_this.queuedRequests.length === 1) {
                        _this.scheduleQueueConsumption();
                    }
                    if (_this.queuedRequests.length === _this.batchMax) {
                        _this.consumeQueue();
                    }
                });
        return requestCopy.observable;
    };
    OperationBatcher.prototype.consumeQueue = function () {
        var requests = this.queuedRequests.map(function (queuedRequest) { return queuedRequest.operation; });
        var forwards = this.queuedRequests.map(function (queuedRequest) { return queuedRequest.forward; });
        var observables = [];
        var nexts = [];
        var errors = [];
        var completes = [];
        this.queuedRequests.forEach(function (batchableRequest, index) {
            observables.push(batchableRequest.observable);
            nexts.push(batchableRequest.next);
            errors.push(batchableRequest.error);
            completes.push(batchableRequest.complete);
        });
        this.queuedRequests = [];
        var batchedObservable = this.batchHandler(requests, forwards) || apollo_link_core_1.Observable.of();
        batchedObservable.subscribe({
            next: function (results) {
                results.forEach(function (result, index) {
                    if (nexts[index]) {
                        nexts[index](result);
                    }
                });
            },
            error: function (error) {
                errors.forEach(function (rejecter, index) {
                    if (errors[index]) {
                        errors[index](error);
                    }
                });
            },
            complete: function () {
                completes.forEach(function (complete) {
                    if (complete) {
                        complete();
                    }
                });
            },
        });
        return observables;
    };
    OperationBatcher.prototype.scheduleQueueConsumption = function () {
        var _this = this;
        setTimeout(function () {
            if (_this.queuedRequests.length) {
                _this.consumeQueue();
            }
        }, this.batchInterval);
    };
    return OperationBatcher;
}());
exports.OperationBatcher = OperationBatcher;
//# sourceMappingURL=batching.js.map